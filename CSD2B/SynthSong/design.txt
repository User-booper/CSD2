Ontwerp voor SynthSong 2B


Ontwerp

SYNTH FOCUS 
- een simpele synth additieve synth en een fm synth





Synth 1:
Een simpele additieve synthesizer. 
Gebruikers kunnen het aantal oscillators instellen. Hiervan ook de pitch, fase en het volume. 



Synth 2:
Een FM synthesizer. ADSR envelopes, frequentie en amplitude waardes van de modulator en carrier oscillators kunnen door de gebruiker worden ingesteld.





Functional design, describing the user interaction flow
Synth 1:
User wordt geprompt voor een aantal variabelen; het aantal oscillatoren en het volume, fase en pitch hiervan. Hierna wordt op basis van deze parameters een vooraf geïnitialiseerd melodie afgespeeld.

Synth 2:
User wordt geprompt voor een aantal variabelen; Voor de Carrier en Modulator oscillator wordt apart de ADSR envelope, frequentie en amplitude (bij modulator de modulation depth) ingesteld. Hierna wordt op basis van deze parameters een vooraf geïnitialiseerd melodie afgespeeld.

Motivatie:
Ik wil graag een simpele synth maken om de basis van audio in C++ onder de knie te krijgen en als dat goed gelukt is, de FM synth bouwen. Ik wilde in eerste instantie kijken of het zou lukken om een granulatie synth te bouwen, maar ik heb er nu toch voor FM gekozen om de scope van het project niet te groot te laten worden.


Plan:
Met Daan tijdens de practica kijken naar oplossingen waneer ik vastloop, en een twee vaste dagen (donderdag en zondag) aanhouden om te werken aan de opdracht.



Psuedocode:

Synth 1
//Initialize amplitudes, frequencies and ADSR.


osc1.setFreq = 220.0f;
osc2.setFreq = 440.0f;

osc1.setAmplitude = 0.9f;
osc2.setAmplitude = 0.9f;

sum = ((osc1.getSample() + osc2.getSample()) / 2) * ADSR.getSample();
 
output = sum;

Synth 2 (FM pseudocode van Ciska, met de amplitude als onderdeel van de oscillators zelf)
// modDepth and carrierFreq are adaptable parameters of the synth

// Initialize amplitudes
modDepth = 100.0f;
carrierAmplitude = 0.9f;
modulator.setAmplitude(modDepth);
carrier.setAmplitude(carrierAmplitude);

// code per sample
modulationSignal = modulator.getSample();
carrier.setFrequency(modulationSignal + carrierFreq);
output = carrier.getSample();


Carrier frequency = note_frequency + (modulator_signal * (mod_depth * (note_frequency * ratio)))





/*
Uitwerking voor granulaire synth.

Synth 2: Met granulaire synthese lees je een buffer met een sample op verschillende posities uit dmv grains. Deze grains kunnen verschillen in hun positie in de buffer(0-1), afspeelduratie (30-300ms?), amplitude, pitch.
Met een aantal variabelen kan de modulatie van deze parameters willekeurig gemaakt worden, bvb spread en spray (spread = positie door de buffer en spray = pitchvariatie)

User Interaction Flow
Synth 2:
User wordt geprompt voor een aantal presets (een stuk of 5) met vaste waardes per preset voor
Spread, spray, het aantal grains en grain size. De preset lopen dan van meer "ambient" / langere grain sizes, naar kortere chaotischere grains. Ook kan de gebruiker kiezen welke sample er in de buffer wordt ingeladen.

Motivatie
Ik wil graag een simpele synth maken om de basis van audio in C++ onder de knie te krijgen en als dat goed gelukt is, de granulatie synth bouwen. Ik merk dat ik daar erg geïnteresseerd in ben en heel enthousiast wordt van het idee om dat te gaan programmeren. Ik denk dat de combinatie van die twee samen goed bij mijn werkwijze aansluit. Granulaire synthese is misschien iets ingewikkeld, maar omdat ik er laatst een in Max gebouwd heb begrijp ik de principes en het mechanisme al vrij goed.

Plan:
Omdat granulaire synthese een vrij ambitieus plan is, wil ik als backup een andere soort synthese achter de hand houden. En met Daan tijdens de practica kijken naar oplossingen waneer ik vastloop
*/
